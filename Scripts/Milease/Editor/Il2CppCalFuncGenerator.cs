#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Milease.CodeGen;
using Milease.Core;
using UnityEditor;
using UnityEngine;

namespace Milease.Editor
{
    public class Il2CppCalFuncGenerator
    {
        [MenuItem("Milease/Generate calculation functions")]
        public static void Generate()
        {
            var path = AssetDatabase.GUIDToAssetPath("80c71963530044e459353fc6947dafe5");
            if (string.IsNullOrEmpty(path))
            {
                EditorUtility.DisplayDialog("Milease",
                    "Please import il2cpp support package first, check it here:\n" +
                    "Project Window -> Packages\\com.morizero.milease\\", "OK");
                return;
            }
            
            EditorUtility.DisplayProgressBar("Milease", "Analyzing animatable types...", 0f);

            var types = GenerationBridge.GetAnimatableTypes();
            if (!EditorUtility.DisplayDialog("Milease",
                    $"Found {types.Count()} animatable type(s), do you want to generate now?",
                    "Yes", "No"))
            {
                EditorUtility.ClearProgressBar();
                return;
            }
            
            EditorUtility.DisplayProgressBar("Milease", "Generating source code...", 0.5f);

            var code = GenerateInternal(types);
            
            EditorUtility.ClearProgressBar();

            var folder = Path.GetDirectoryName(path);
            path = Path.Combine(folder!, "GeneratedCalculation.cs");
            
            File.WriteAllText(path, code);
            
            AssetDatabase.Refresh();
            AssetDatabase.ImportAsset(path);
        }
        
        [MenuItem("Milease/Reset calculation functions")]
        public static void Reset()
        {
            var path = AssetDatabase.GUIDToAssetPath("80c71963530044e459353fc6947dafe5");
            if (string.IsNullOrEmpty(path))
            {
                EditorUtility.DisplayDialog("Milease",
                    "Please import il2cpp support package first, check it here:\n" +
                    "Project Window -> Packages\\com.morizero.milease\\", "OK");
                return;
            }
            
            EditorUtility.DisplayProgressBar("Milease", "Resetting source code...", 0.5f);

            var code = GenerateInternal(ArraySegment<Type>.Empty);
            
            EditorUtility.ClearProgressBar();

            var folder = Path.GetDirectoryName(path);
            path = Path.Combine(folder!, "GeneratedCalculation.cs");
            
            File.WriteAllText(path, code);
            
            AssetDatabase.Refresh();
            AssetDatabase.ImportAsset(path);
        }
        
        private static string GenerateInternal(IEnumerable<Type> types)
        {
            string template;
            var sb = new StringBuilder();
            sb.AppendLine(
@"// This file is generated by Milease automatically

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace Milease.CodeGen
{
    public delegate E CalculateFunction<E>(E start, E end, float progress);
    public delegate E OffsetCalculateFunction<E>(E start, E end, float progress, E offset);
    public static partial class GeneratedCalculation
    {
        private static readonly Dictionary<Type, object> calculateFunctions = new()
        {");

            template = "            [typeof(<<t>>)] = new CalculateFunction<<<t>>>(_mil_generated_calc),";
            foreach (var type in types)
            {
                sb.AppendLine(template.Replace("<<t>>", type.FullName));
            }
            
            sb.AppendLine(
@"            [typeof(ushort)] = new CalculateFunction<ushort>(_mil_generated_calc),
            [typeof(short)] = new CalculateFunction<short>(_mil_generated_calc),
            [typeof(uint)] = new CalculateFunction<uint>(_mil_generated_calc),
            [typeof(int)] = new CalculateFunction<int>(_mil_generated_calc),
            [typeof(ulong)] = new CalculateFunction<ulong>(_mil_generated_calc),
            [typeof(long)] = new CalculateFunction<long>(_mil_generated_calc),
            [typeof(float)] = new CalculateFunction<float>(_mil_generated_calc),
            [typeof(double)] = new CalculateFunction<double>(_mil_generated_calc),
            [typeof(object)] = new CalculateFunction<object>(_mil_generated_calc)
        };

        private static readonly Dictionary<Type, object> offsetCalculateFunctions = new()
        {");
            
            template = "            [typeof(<<t>>)] = new OffsetCalculateFunction<<<t>>>(_mil_generated_calc_offset),";
            foreach (var type in types)
            {
                sb.AppendLine(template.Replace("<<t>>", type.FullName));
            }
            
            sb.AppendLine(
@"            [typeof(ushort)] = new OffsetCalculateFunction<ushort>(_mil_generated_calc_offset),
            [typeof(short)] = new OffsetCalculateFunction<short>(_mil_generated_calc_offset),
            [typeof(uint)] = new OffsetCalculateFunction<uint>(_mil_generated_calc_offset),
            [typeof(int)] = new OffsetCalculateFunction<int>(_mil_generated_calc_offset),
            [typeof(ulong)] = new OffsetCalculateFunction<ulong>(_mil_generated_calc_offset),
            [typeof(long)] = new OffsetCalculateFunction<long>(_mil_generated_calc_offset),
            [typeof(float)] = new OffsetCalculateFunction<float>(_mil_generated_calc_offset),
            [typeof(double)] = new OffsetCalculateFunction<double>(_mil_generated_calc_offset),
            [typeof(object)] = new OffsetCalculateFunction<object>(_mil_generated_calc_offset)
        };

        public static CalculateFunction<E> GetFunc<E>()
        {
            if (!calculateFunctions.TryGetValue(typeof(E), out var result))
            {
                result = new CalculateFunction<E>((a, b, p) => (E)_mil_generated_calc(a, b, p));
                calculateFunctions.Add(typeof(E), result);
            }
            return (CalculateFunction<E>)result;
        }
        
        public static OffsetCalculateFunction<E> GetOffsetFunc<E>()
        {
            if (!offsetCalculateFunctions.TryGetValue(typeof(E), out var result))
            {
                result = new OffsetCalculateFunction<E>((a, b, p, o) => (E)_mil_generated_calc_offset(a, b, p, o));
                offsetCalculateFunctions.Add(typeof(E), result);
            }
            return (OffsetCalculateFunction<E>)result;
        }
        ");
            
            template = 
@"        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <<t>> _mil_generated_calc(<<t>> a, <<t>> b, float p)
        {
            return a + (b - a) * p;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <<t>> _mil_generated_calc_offset(<<t>> a, <<t>> b, float p, <<t>> o)
        {
            return a + (b - a) * p + o;
        }
        ";
            foreach (var type in types)
            {
                sb.AppendLine(template.Replace("<<t>>", type.FullName));
            }
            
            sb.AppendLine(
@"        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort _mil_generated_calc(ushort a, ushort b, float p)
        {
            return (ushort)(a + (b - a) * p);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort _mil_generated_calc_offset(ushort a, ushort b, float p, ushort o)
        {
            return (ushort)(a + (b - a) * p + o);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static short _mil_generated_calc(short a, short b, float p)
        {
            return (short)(a + (b - a) * p);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static short _mil_generated_calc_offset(short a, short b, float p, short o)
        {
            return (short)(a + (b - a) * p + o);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint _mil_generated_calc(uint a, uint b, float p)
        {
            return (uint)(a + (b - a) * p);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint _mil_generated_calc_offset(uint a, uint b, float p, uint o)
        {
            return (uint)(a + (b - a) * p + o);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int _mil_generated_calc(int a, int b, float p)
        {
            return (int)(a + (b - a) * p);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int _mil_generated_calc_offset(int a, int b, float p, int o)
        {
            return (int)(a + (b - a) * p + o);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong _mil_generated_calc(ulong a, ulong b, float p)
        {
            return (ulong)(a + (b - a) * p);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong _mil_generated_calc_offset(ulong a, ulong b, float p, ulong o)
        {
            return (ulong)(a + (b - a) * p + o);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long _mil_generated_calc(long a, long b, float p)
        {
            return (long)(a + (b - a) * p);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long _mil_generated_calc_offset(long a, long b, float p, long o)
        {
            return (long)(a + (b - a) * p + o);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float _mil_generated_calc(float a, float b, float p)
        {
            return a + (b - a) * p;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float _mil_generated_calc_offset(float a, float b, float p, float o)
        {
            return a + (b - a) * p + o;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double _mil_generated_calc(double a, double b, float p)
        {
            return a + (b - a) * p;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double _mil_generated_calc_offset(double a, double b, float p, double o)
        {
            return a + (b - a) * p + o;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static object _mil_generated_calc(object a, object b, float p)
        {
            return (p >= 1f ? b : a);
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static object _mil_generated_calc_offset(object a, object b, float p, object o)
        {
            return (p >= 1f ? b : a);
        }
    }
}");

            return sb.ToString();
        }
    }
}
#endif
